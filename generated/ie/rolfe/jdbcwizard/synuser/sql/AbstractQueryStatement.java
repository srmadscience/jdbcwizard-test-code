package ie.rolfe.jdbcwizard.synuser.sql;


import java.sql.*; 
import com.orindasoft.pub.LogInterface; 
import com.orindasoft.pub.StatsInterface; 
import com.orindasoft.pub.OracleResourceUser; 
import com.orindasoft.pub.QueryStatement;
import com.orindasoft.pub.ReadOnlyRowSet;
import com.orindasoft.pub.CSException; 

/** 
* Abstract SQL statement class for all query classes generated by JDBCWizard
* 
* <p>Generated by JDBCWizard build 3145 at 2025/11/14 10:01:43.338 EST
* <p>JDBCWizard is made by <a href="http://www.orindasoft.com/?pdsrc=GD3145" target="_blank">Orinda Software Ltd, Dublin, Ireland</a>
* <p>Target Database: Oracle 12.1.0
* <p> -------------------------------------------------------------------------
* <p> WARNING: This code will stop working around the time JDBCWizard expires.
* <p> This restriction only exists in the demo version of JDBCWizard.
* <p> -------------------------------------------------------------------------
* <p> JDBCWizard Tips 15 of 19:
* <p> JDBCWizard never needs to access a production system.
* <p> It writes human readable code and uses a library that you get the 
* <p> source code for if you buy JDBCWizard. If you buy it you will end
* <p> up with all the source code you need.
* <p> -------------------------------------------------------------------------
* 
* <p>

* @author rolfe.ie
*/ 
public abstract class AbstractQueryStatement implements OracleResourceUser, StatsInterface 
{ 
  /** 
  * Constant used for object that is in this users account 
  */ 
  public static final int THIS_USERS_OBJECT = 0; 
  
  /** 
  * Constant used for object that is in an other users account 
  */ 
  public static final int OTHER_USERS_OBJECT = 1; 
  
  /** 
  * Constant used for object that is a refered to by a PRIVATE SYNONYM 
  */ 
  public static final int THIS_USERS_SYNONYM = 2; 
  
  /** 
  * Constant used for object that is a refered to by a PUBLIC SYNONYM 
  */ 
  public static final int PUBLIC_SYNONYM = 3; 
  
  /** 
  * Database Connection 
  */ 
  public Connection theConnection = null; 
  
  /** 
  * An instance of a class which implements com.orindasoft.pub.LogInterface 
  */ 
  public com.orindasoft.pub.LogInterface theLog = null; 
  
  /** 
  * QueryStatement used to run query 
  */ 
  public QueryStatement theStatement = null; 
  
  /** 
  * Build Number - Added to spot conflicts between version of generated code 
  * and version of com.orindasoft.pub Library. 
  * @since 6.0.2706 
  */ 
  private static final int theBuildNumber =  3145;
  
  /** 
  * Create an instance of AbstractQueryStatement using a database connection and an instance of LogInterface 
  *  @param Connection theConnection A database connection 
  *  @param LogInterface theLog An instance of a class that  com.orindasoft.pub.LogInterface 
  */ 
  public AbstractQueryStatement(Connection theConnection, LogInterface theLog) 
    { 
    theLog.debug("AbstractQueryStatement - Started"); //DEBUG
    this.theConnection = theConnection; 
    this.theLog = theLog; 
    } 
   
  /** 
  * Create an instance of AbstractQueryStatement using an instance of LogInterface  
  *  @param LogInterface theLog An instance of a class that  com.orindasoft.pub.LogInterface  
  */                                   
  public AbstractQueryStatement(LogInterface theLog)      
    {                                                 
    theLog.debug("AbstractQueryStatement - Started"); //DEBUG
    this.theLog = theLog;                             
    }                                                  
   
  /**  
  * Set or reset the database connection 
  *  @param Connection theConnection A database connection  
  */       
  public void setConnection(Connection theConnection)  
    {                                               
    theLog.debug("AbstractQueryStatement - Setting DB Connection"); //DEBUG
    this.theConnection = theConnection;          
    theStatement.setConnection(theConnection); 
    }                                           
   
  /**  
  * Set flag that controls whether LOBs are turned into files or not. 
  *  @param boolean keepLobs   
  *  @since 2.0.1505   
  */       
  public void setKeepLobs(boolean keepLobs)  
    {                                               
    theStatement.setKeepLobs(keepLobs);          
    }                                           
   
  /**  
  * Get flag that controls whether LOBs are turned into files or not. 
  *  @return boolean keepLobs   
  *  @since 2.0.1505   
  */       
  public boolean getKeepLobs()  
    {                                               
    return(theStatement.getKeepLobs());          
    }                                           
   
  /**  
  * Set flag that controls whether LOBs are turned into byte[]
  *  @param boolean useByteArraysForLongsAndLOBS  flag that specifies whether lobs such as CLOBS, BLOBS and BFILES  
  *  @since 5.0.2314   
  */       
  public void setUseByteArraysForLongsAndLOBS(boolean useByteArraysForLongsAndLOBS)  
    {                                               
    theStatement.setUseByteArraysForLongsAndLOBS(useByteArraysForLongsAndLOBS);          
    }                                           
   
  /**  
  * Get flag that controls whether LOBs are turned into byte[]. 
  *  @return boolean useByteArraysForLongsAndLOBS   
  *  @since 5.0.2314   
  */       
  public boolean getUseByteArraysForLongsAndLOBS()  
    {                                               
    return(theStatement.getUseByteArraysForLongsAndLOBS());          
    }                                           
   
  /** 
  * Return a string containing the magic incantation needed to execute this. 
  */ 
  public abstract String getProcCallStatement(); 
  
  /** 
  * Bind Parameters object if needed. 
  */ 
  protected abstract void bindParams() throws CSException; 
   
  /** 
  * Issue query and get results from the database 
  * @return ReadOnlyRowSet the result of the query
  * @throws CSException A runtime error of some kind. See <a href=http://www.orindasoft.com/?pdsrc=GD3145csexeceptions>CSExceptions</a>
  */ 
  public ReadOnlyRowSet executeQuery() throws CSException
    {                                                                   
    // See if our statement is usable. If somebody else who has the connection has called 
    // its commit method out prepared statement will no longer be usable...     
    theLog.debug("AbstractQueryStatement - Executing Query"); //DEBUG
     
    // Make sure generated code version matches version of this code...
    com.orindasoft.pub.StatementParameters2.checkBuild(theBuildNumber);
                          
    bindParams();       
    return (theStatement.execute());        
    }                       
  
   
  /** 
  * Release all Oracle db resources that we know to be in use. 
  *  @return boolean <code>true</code> if we didn't encounter any problems, otherwise <code>false</code> 
  */ 
   
  public boolean releaseResources() 
    { 
    boolean returnCode = true; 
    
    theLog.debug("AbstractQueryStatement - Attempting to release connection");
    try 
      { 
      
      if (theStatement != null)
        { 
        theStatement.releaseResources(); 
        } 
      } 
    catch (Exception e) 
      { 
      theLog.warning(e.toString()); 
      returnCode = false; 
      } 
    
    theConnection = null; 
    theLog.debug("AbstractQueryStatement- Finished releasing connection");
    
    return(returnCode); 
    } 
  
  /** 
  * Check to see if we are using Oracle Resources
  * @return <code>true</code> if we are using resources
  * @return <code>false</code> if we are not using resources
  */ 
  public boolean hasResources() 
    { 
    if (theConnection == null) 
      { 
      return (false); 
      } 
    
    return(true); 
    } 
   
  /**                                                        
  * Reset all stats counters to 0. Used to implement StatsInterface    
  * @see StatsInterface  
  */                                                         
  public void resetStatsCounters()      
    {                                  
    theStatement.resetStatsCounters(); 
    }                            
                             
  /**                                                        
  * Return counter containing number of parses. Used to implement StatsInterface    
  * @see StatsInterface  
  */                                                         
  public long getParses()      
    {                               
    return (theStatement.getParses());           
    }                             
  
  /**                                                        
  * Return counter containing time spent parsing in milliseconds. Used to implement StatsInterface    
  * @see StatsInterface  
  */                                                         
  public long getParseTime()      
    {                               
    return (theStatement.getParseTime());           
    }                             
  
  /**                                                        
  * Return counter containing number of executions. Used to implement StatsInterface    
  * @see StatsInterface  
  */                                                         
  public long getExecutions()     
    {                               
    return (theStatement.getExecutions());       
    }                                  
   
  /**                                                        
  * Return counter containing time spent executing statement in milliseconds. Used to implement StatsInterface    
  * @see StatsInterface  
  */                                                         
  public long getExecutionTime()     
    {                               
    return (theStatement.getExecutionTime());       
    }                                  
   
  /**                                                        
  * Return counter containing time spent retrieving data in milliseconds. Used to implement StatsInterface    
  * @see StatsInterface  
  */                                                         
  public long getRetrievalTime()     
    {                               
    return (theStatement.getRetrievalTime());       
    }                                  
   
  /**                                                        
  * Return counter containing number of releases. Used to implement StatsInterface    
  * @see StatsInterface  
  */                                                         
  public long getReleases()             
    {                                
    return (theStatement.getReleases());                
    }                              
   
  /**                                                        
  * Return counter containing number of errors. Used to implement StatsInterface    
  * @see StatsInterface  
  */                                                         
  public long getErrors()             
    {                                
    return (theStatement.getErrors());                
    }                              
  
  
  /**
  * Specify how long results will be cached.
  *
  * Setting this to a non-zero value turns caching on.
  * @param int newCacheSeconds
  */
  public void setCacheSeconds(int newCacheSeconds)
    {
    theStatement.setCacheSeconds(newCacheSeconds);
    }
  
  /**
  * Specify how many results will be cached.
  *
  * By default this is DEFAULT_QUERIES_CACHED.
  * @param int newCacheSeconds
  */
  public void setCacheRows(int newCacheRows)
    {
    theStatement.setCacheRows(newCacheRows);
    }
  
  /**
  * Return the number of queries currently in the cache.
  */
  public int getCacheSize()
    {
    return (theStatement.getCacheSize());
    }
  
  /**
  * Clear the cache.
  */
  public void clearCache()
    {
    theStatement.clearCache();
    }
  
  /**
  * Specify how many rows can be brought back
  *
  * @param int newQueryRows
  */
  public void setQueryRows(int newQueryRows)
    {
    theStatement.setQueryRows(newQueryRows);
    }
  
  /**
  * Remove entries that are too old from the cache
  * @param int howManyMilliseconds The maximum amount of time to be spent removing entries.
  * @return int How many entries were removed.
  */
  public int purgeExpiredCacheEntries(int howManyMilliseconds)
    {
    return(theStatement.purgeExpiredCacheEntries(howManyMilliseconds));
    }
  
  /**
  * Remove entries that have not been reused from the cache
  * @param int minAcceptableReuses How many times an entry must have been used to avoid
  * deletion.
  * @param int howManyMilliseconds The maximum amount of time to be spent removing entries.
  * @return int How many entries were removed.
  */
  public int purgeUnderusedCacheEntries(int minAcceptableReuses,int howManyMilliseconds)
    {
    return(theStatement.purgeUnderusedCacheEntries(minAcceptableReuses,howManyMilliseconds));
    }
  
  /**
  * Return an up to date signature of the query parameters.
  */
  public String getLatestQuerySignature()
    {
    return(theStatement.getLatestQuerySignature());
    }
  
  /**
  * Get current file io buffer size
  * @return int bufferSize Buffersize in bytes.
  */
  public int getBufferSize()
    {
    return (theStatement.getBufferSize());
    }
  
  /**
  * Get keepFiles flag
  * @return int <code>true</code> if temporary files are kept after the JVM exits.
  * @return int <code>false</code> if temporary files are deleted after the JVM exits.
  */
  public boolean getKeepFiles()
    {
    return (theStatement.getKeepFiles());
    }
  
  /**
  * Get temporary directory
  * @preturn java.io.File tempFileDir the temporary Directory
  */
  public java.io.File getTempDir()
    {
    return(theStatement.getTempDir());
    }
  
  /**
  * Get the prefix used for generating temporary files
  */
  public String getTempFilePrefix()
    {
    return (theStatement.getTempFilePrefix());
    }
  
  /**
  * Get the suffix used for generating temporary files
  */
  public String getTempFileSuffix()
    {
    return (theStatement.getTempFileSuffix());
    }
  /**
  * Set new file io buffer size
  * @param int bufferSize A new Buffersize in bytes.
  */
  public void setBufferSize(int bufferSize)
    {
    theStatement.setBufferSize(bufferSize);
    }
  
  /**
  * Set keepFiles
  * @param boolean keepFiles Keep generated files after JVM exits
  */
  public void setKeepFiles(boolean keepFiles)
    {
    theStatement.setKeepFiles(keepFiles);
    }
  
  /**
  * Set temporary directory
  * @param java.io.File tempFileDir a new Temporary Directory
  * @throws CSException if the directory is not viable
  */
  public void setTempDir(java.io.File tempFileDir) throws CSException
    {
    theStatement.setTempDir(tempFileDir);
    }
  
  /**
  * Set the prefix used for generating temporary files
  */
  public void setTempFilePrefix(String tempFilePrefix)
    {
    theStatement.setTempFilePrefix(tempFilePrefix);
    }
  
  /**
  * Set the suffix used for generating temporary files
  */
  public void setTempFileSuffix(String tempFileSuffix)
    {
    theStatement.setTempFileSuffix(tempFileSuffix);
    }
  } // Generated by JDBCWizard 6.0.3145  
